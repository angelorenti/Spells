% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Counting.R
\name{spell_order}
\alias{spell_order}
\title{impute episode order for episodes of a given reference state}
\usage{
spell_order(
  x,
  state = "Inactive",
  increasing = TRUE,
  step_size = 1,
  condition = c("total", "entry", "exit")
)
}
\arguments{
\item{x}{character vector of state in each time step}

\item{state}{character. The reference state. Could be a vector of states too.}

\item{increasing}{logical. Default \code{TRUE}. If \code{clock_type} is either \code{"step"} or \code{"order"} do we count up or count down?}

\item{step_size}{numeric. Default \code{1}. What is the time interval for the discrete bins in \code{x}.}

\item{condition}{character. For duration clocks, one of \code{"total"}, \code{"entry"}, or \code{"exit"}. Default \code{"total"}.}
}
\description{
produce a vector of \code{length(x)} values corresponding to the order of each episode of the reference state.
}
\details{
\code{NA} are given for other states. \code{state} can be a vector of states if you'd rather consider certain states merged into single episodes.
}
\examples{
x <- rep(c("Employed", "Inactive", "Retired", "Employed", "Retired", 
				"Dead"), c(7,  8,  3,  3, 25,  5))
# only one spell of inactivity
spell_order(x, state = "Inactive", increasing = TRUE)
# two spells of employment
spell_order(x, state = "Employed", increasing = TRUE)
spell_order(x, state = "Employed", increasing = FALSE)
}
